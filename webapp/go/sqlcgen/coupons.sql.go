// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: coupons.sql

package sqlcgen

import (
	"context"
)

const createCoupons = `-- name: CreateCoupons :execrows
INSERT INTO coupons (user_id, code, discount) VALUES (?, ?, ?)
`

type CreateCouponsParams struct {
	UserID   string
	Code     string
	Discount int32
}

func (q *Queries) CreateCoupons(ctx context.Context, arg CreateCouponsParams) (int64, error) {
	result, err := q.db.Exec(ctx, createCoupons, arg.UserID, arg.Code, arg.Discount)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createCouponsWihtCalc = `-- name: CreateCouponsWihtCalc :execrows
INSERT INTO coupons (user_id, code, discount) VALUES (?, CONCAT(?, '_', FLOOR(UNIX_TIMESTAMP(NOW(3))*1000)), ?)
`

type CreateCouponsWihtCalcParams struct {
	UserID   string
	CONCAT   interface{}
	Discount int32
}

func (q *Queries) CreateCouponsWihtCalc(ctx context.Context, arg CreateCouponsWihtCalcParams) (int64, error) {
	result, err := q.db.Exec(ctx, createCouponsWihtCalc, arg.UserID, arg.CONCAT, arg.Discount)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getCouponsByCode = `-- name: GetCouponsByCode :many
SELECT user_id, code, discount, created_at, used_by FROM coupons WHERE code = ? FOR UPDATE
`

func (q *Queries) GetCouponsByCode(ctx context.Context, code string) ([]Coupon, error) {
	rows, err := q.db.Query(ctx, getCouponsByCode, code)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Coupon
	for rows.Next() {
		var i Coupon
		if err := rows.Scan(
			&i.UserID,
			&i.Code,
			&i.Discount,
			&i.CreatedAt,
			&i.UsedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
